---
layout: post
title:  "Побочные эффекты, как основной результат работы программы"
date: 2007-12-31 02:51:00 -0000
tags: Программирование LISP
---

Наша [программа euler](imperative-vs-functional) по-прежнему не делает одной вещи, которую выполняет программа на бейсике. Та выдаёт журнал своей работы. Строка `PRINT x,y` отчитывается о каждом цикле программы. Такие отчёты нужны для отладки программ, кроме того, они позволяют вести журналы вычислений и других действий. 

Для выдачи таких отчётов в LISP-программе придётся также использовать свои механизмы, отличные от применяемых в императивных языках.

Идеальная функциональная программа вообще ничего не меняет в системе, она получает что-то на входе, обрабатывает эти строки, числа и списки по заложенному в  неё алгоритму и выдаёт результат. Может быть это даже будет <a href="http://ru.wikipedia.org/wiki/%D0%9E%D1%82%D0%B2%D0%B5%D1%82_%D0%BD%D0%B0_%D0%B3%D0%BB%D0%B0%D0%B2%D0%BD%D1%8B%D0%B9_%D0%B2%D0%BE%D0%BF%D1%80%D0%BE%D1%81_%D0%B6%D0%B8%D0%B7%D0%BD%D0%B8,_%D0%B2%D1%81%D0%B5%D0%BB%D0%B5%D0%BD%D0%BD%D0%BE%D0%B9_%D0%B8_%D0%B2%D1%81%D0%B5%D0%B3%D0%BE_%D1%82%D0%B0%D0%BA%D0%BE%D0%B3%D0%BE">42</a> . Она не печатает результатов, не пишет на диск и даже не создаёт переменных, в идеальной функциональной программе даже нет таких понятий. Но в нашем материальном мире такие вещи нужны и LISP умеет обращаться к базам данных, запрашивать ввод от пользователя, писать на диск, использовать переменные и выводить данные на экран. Просто все эти действия называются побочными эффектами, вроде как такой добавкой к основному действию LISP-символа.

Печать на экран — тоже побочный эффект. Для этого есть символ print, который выводит аргумент на экран, а перед ним делает перевод строки. И символы prin1 и princ, разница между ними для нас сейчас непренципиальна. Они просто выводят аргумент на экран, не делая перед ним перевода строки. Печать на экране для них побочное действие, в качестве основного они просто возвращают свой аргумент. Так что `(+ 2 3)` просто посчитает выражение (и тоже напечатает его на экране, но это уже любезно сделает для нас интерпретатор лиспа), а `(print (+ 2 3))` посчитает выражение и выведет результат на экран.

Зная это совсем просто переделать программу так, чтобы она отчитывалась о ходе вычислений:

```
(defun euler (y x dx xmax func)
;;;; approximate solution of differential equations of euler method
;;;; print log evry iteration
  (if (<= x xmax)
        (euler (print (+ (* (funcall func x) dx) y)) (princ (+ x dx)) dx xmax func)
        y
        )
)
```

Другие побочные эффекты от этой программы нам не нужны. Мы получили программу:

- гораздо короче, чем исходный код на бейсике;
- более универсальную, она может численно дифференцировать любую, переданную ей функцию одного аргумента;
- более наглядную (хотя тут могут быть совершенно противоположные мнения, всё дело в привычке).

Исходный код приведённого примера можно <a href="http://2nature.me/files/example3.lsp">скачать</a>.