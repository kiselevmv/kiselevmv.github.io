---
layout: post
title:  "Черим линию из точек. Часть 3"
date: 2020-08-07 21:45:00 -0000
tags: Форт программирование
description: "Пост в котором вявляются очевидные недостатки языка программирования Форт."
---

После [первой неудачной попытки](/blog/2020/make-line-from-dots) реализовать компьютерную графику на языке программирования Форт. И [второй](/blog/2020/make-line-from-dots2), удачной, попытки реализовать компьютерную графику на Си я снова попробовал вернуться к Форт. Для этого я вставил в [pForth](http://www.softsynth.com/pforth/) собственные функции для рисования непосредственно в графических файлах в формате bmp. На этот раз всё заработало великолепно. Но теперь я понимаю, почему на Форте больше никто не пишет. Я продолжу, пожалуй, для меня это интеллектуальное развлечение. Но теперь я понимаю, что с точки зрения профессионального программирование некоторые плюсы языка Форт не перевешивают его очевидного минуса. Для понимания, что происходит на стеке нужна немалая практика. Она приобретается, я уверен. Но входной порог высок. И даже насмотренному программисту не получится понять всю логику работы с одного взгляда. 

Для примера - ниже два листинга программ. Первый - на Си. Второй - на Форт. Они делают один и тот же рисунок. В обеих случаях собственно графическая библиотека вынесена из текста программы. В Си она подключена, как внешняя библиотека. В Форт она "вшита" в сам язык. Также я пытался сделать код хоршо откоментированным и ясным. То, что в программе на Форт комментариев больше - следствие сложности.

В качестве модели для рисования я использовал Godseye. В основном потому, что алгоритм очень прост и мне нравится узор.

![Godseye](https://res.cloudinary.com/dlqc5rp9l/image/upload/v1596710485/graphics/godseye_tml59e.png)

## Чертим GODSEYE программой на Си

```C
#include "graphlib.h"
#define SIDES				15

/* Creates Godseye  */
int main( int argc, char* argv[] )
{
    int i;            // for cycle counters only
    int id1, id2;

    /* Create canvas for drawing */
    InitGraph ( 30, 22, 800, 600 );
	SetOrigin( Horiz/2, Vert/2 );

	MoveTo( 10, 0 );
	LineTo( -10, 0 );
	MoveTo( 0, 10 );
	LineTo( 0, -10 );

    /* Draw Godseye edges using cycle  */
    for ( i = 0 ; i < SIDES ; ++i ) 
    {
		id1 = (int)(i * 10.0 / SIDES);
		id2 = (int)(( SIDES +  1 - i ) *10.0 / SIDES);
		MoveTo((int)id1, 0);
		LineTo(0, (int)id2);
		LineTo(-(int)id1, 0);
		LineTo(0, -(int)id2);
		LineTo((int)id1, 0);
    }
	
	Stroke();
	CloseGraph();
}
```

Возможно, дело в "насмотренности" программ на Си, но это легко читаемый и понимаемый код на императивном языке программирования. Чёткая структура, названия функций достаточно говорящие, чтобы понимать о чём они, а детали реализации можно подсмотреть в исходном коде с подробными комментариями.

## Чертим GODSEYE программой на Форт

```Forth
: SIDES 15 ;

: DRAW-CROSS
15 11 SETORIGIN
10 0 MOVETO
-10 0 LINETO
0 10 MOVETO
0 -10 LINETO ;

: DRAW-LOZENGE ( id1 id2 -- )
SWAP 	( id2 id1 )
DUP 	( id2 id1 id1 )
0 	( id2 id1 id1 0 )
MOVETO	( id2 id1 )
SWAP	( id1 id2 )
DUP	( id1 id2 id2 )
0	( id1 id2 id2 0 )
SWAP	( id1 id2 0 id2 )
LINETO	( id1 id2 )
SWAP	( id2 id1 )
DUP	( id2 id1 id1 )
-1 * 0	( id2 id1 -id1 0 )
LINETO	( id2 id1 )
0 	( id2 id1 0 )
ROT	( id1 0 id2 )
-1 *	( id1 0 -id2 )
LINETO	( id1 )
0	( id1 0 )
LINETO ;

: DRAW-EDGES
SIDES 1 DO
I	( I )
DUP	( I I )
SIDES 1+ ( I I SIDES+1 )
SWAP
-	( I SIDES+1-I )
10 *	( I SIDES+1-I*10 )
SIDES
/	( I id2 )
SWAP
10 *	( id2 I*10 )
SIDES   ( id2 I*10 SIDES )
/	( id2 id1 )
DRAW-LOZENGE
LOOP ;

: GODSEYE
30 22 800 600 INITGRAPH
DRAW-CROSS
DRAW-EDGES
STROKE
CLOSEGRAPH ;
```

В скобках после большинства строк - комментарий с ожидаемым состоянием стека. Без них мне было бы непросто разобраться с тем, что проихсодит. Названия слов относительно говорящие, можно было бы добавить комментариев. Технически, программа на Форт могла бы быть чрезвычайно лаконична

```Forth
: SIDES 15 ;

: DRAW-CROSS 15 11 SETORIGIN 10 0 MOVETO -10 0 LINETO 0 10 MOVETO 0 -10 LINETO ;

: DRAW-LOZENGE 
SWAP DUP 0 MOVETO
SWAP DUP 0 SWAP LINETO
SWAP DUP -1 * 0	LINETO
0 ROT -1 * LINETO
0 LINETO ;

: DRAW-EDGES
SIDES 1 DO
I DUP  SIDES 1+ SWAP - 10 * SIDES / SWAP 10 * SIDES / DRAW-LOZENGE
LOOP ;

: GODSEYE 30 22 800 600 INITGRAPH DRAW-CROSS DRAW-EDGES STROKE CLOSEGRAPH ;
```

Это похоже на [обфускацию кода](https://habr.com/ru/post/255871/) но в некоторых отношениях код на Форт стал более понятным, а программа на Си при таком сжатии стала бы полностью нечитаемой.

Когда появляется "начитанность" и можно читать относительно несложный код на Форт без диаграм стека в комментариях - второй вариант делается даже предпочтительным. Я мог бы использовать особенность pForth - [локальные переменные](http://www.softsynth.com/pforth/pf_ref.php#Local-Variables) внутри слов. Это сделало бы код куда более читаемым, но жёстко привязанным к pForth. Вот третий вариант.

```Forth
: SIDES 15 ;

: NEG -1 * ;

: DRAW-CROSS
15 11 SETORIGIN
10 0 MOVETO -10 0 LINETO
0 10 MOVETO 0 -10 LINETO ;

: DRAW-LOZENGE { id1 id2 -- }
id1 0 MOVETO
0 id2 LINETO
id1 NEG * 0 LINETO
0 id2 NEG LINETO
id1 0 LINETO ;

: DRAW-EDGES
SIDES 1 DO
I
SIDES 1+ ( I SIDES+1 )
SWAP -	 ( SIDES+1-I )
10 *	( SIDES+1-I*10 )
SIDES /	( id2 )
I  		( id2 I )
10 *	( id2 I*10 )
SIDES /	( id2 id1 )
DRAW-LOZENGE
LOOP ;

: GODSEYE
30 22 800 600 INITGRAPH
DRAW-CROSS
DRAW-EDGES
STROKE
CLOSEGRAPH ;
```

Локальные переменные "стоят" недорого, но кардинально облегчают чтение программы. Сама по себе концепция стека проста, сложно даётся жонглирование числами на стеке. К сожалению, в классическом ANSI Форт такой возможности небыло. Думаю, это была одной из причин того, что язык вымер как мамонт.

Теперь о некоторых субъективных плюсах языка:

- Форт поощряет декомпозицию программ. *Считается* хорошим стилем делить программы на как можно более [короткие функции](https://habr.com/ru/post/310590/). Проблема в том, что вызов функций в большинстве языков ухудшает читаемость программы. Мы что-то отдаём и что-то получаем. В Си и Си++ нужно думать об ограничении на возвращение функцией одного значения. Значит, приходится либо созадвать структуры вместо переменных, даже там, где они не нужны. Либо передавать ссылки на значения. Кроме того, каждый вызов функции что-то "стоит" и снижает скорость и эффективность программы. Это малосущественно, но таких вызовов тысячи. За счёт того, что Форту ничего специально передавать не приходится, всё, что нужно уже на стеке - вызов слова ничего не "стоит" и прибегать к декомпозиции на короткие кусочки легко и приятно.
- Эффективный код. Сама по себе ограниченность возможностей стимулирует к более эффективному коду. Использованию арифметики с фиксированной точкой вместо плавающей точки, упрощение кода. Мне ещё потребуется сравнить скорость выполнения кода между программой на Форт и Си. Пока это чисто умозрительное заключение.
- Простой синтаксис и широкие возможности его расширения. В Форт изначально нет "[синтаксического сахара](https://habr.com/ru/post/128667/)". Про его вред много пишут, но в современных языках программирования его всё больше. В итоге появляется четыре разных синтаксических конструкции для записи одного кода и это снижает читаемость кода. Ну, не настолько, насколько стековые манипуляции Форт, но всё же. В то же время, возможности языка позволяют создавать собственные синтаксические конструкции под конкрнетную задачу. Я видел Форт-программы, которые были образцом читаемости и ясности. Другое дело, сколько усилий потратили программисты на создание [DSL](https://www.jetbrains.com/mps/concepts/domain-specific-languages/) под конкретную задачу. Трудно сказать, стоит ли оно того, но это **красиво**.

Думаю, есть и ещё преимущества. Я планирую продолжить реализовывать простейшие алгоритмы компьютерной графики в Форт и попробовать сделать DSL под эти цели.